The data in a data cube cannot be generated by a single SQL query, using the
basic group by constructs, since aggregates are computed for several different
groupings of the dimension attributes. For this reason, SQL includes functions to
form the grouping needed for OLAP. We discuss these below.
SQL supports generalizations of the group by construct to perform the cube
and rollup operations. The cube and rollup constructs in the group by clause
allow multiple group by queries to be run in a single query with the result
returned as a single relation in a style similar to that of the relation of Figure 5.21.
Consider again our retail shop example and the relation:
sales (item name, color, clothes size, quantity)
We can find the number of items sold in each item name by writing a simple
group by query:
select item name, sum(quantity)
from sales
group by item name;
The result of this query is shown in Figure 5.23. Note that this represents the same
data as the last column of Figure 5.17 (or equivalently, the first row in the cube of
Figure 5.18).
Similarly, we can find the number of items sold in each color, etc. By using
multiple attributes in the group by clause, we can find how many items were
sold with a certain set of properties. For example, we can find a breakdown of
sales by item-name and color by writing:
select item name, color, sum(quantity)
from sales
group by item name, color;
The result of this query is shown in Figure 5.24. Note that this represents the
same data as is shown in the the first 4 rows and first 4 columns of Figure 5.17 (or
equivalently, the first 4 rows and columns in the cube of Figure 5.18).
If, however, we want to generate the entire data cube using this approach, we
would have to write a separate query for each of the following sets of attributes:
5.6 OLAP 207
item name color quantity
skirt dark 8
skirt pastel 35
skirt white 10
dress dark 20
dress pastel 10
dress white 5
shirt dark 14
shirt pastel 7
shirt white 28
pants dark 20
pants pastel 2
pants white 5
Figure 5.24 Query result.
{ (item name, color, clothes size), (item name, color), (item name, clothes size),
(color, clothes size), (item name), (color), (clothes size), () }
where () denotes an empty group by list.
The cube construct allows us to accomplish this in one query:
select item name, color, clothes size, sum(quantity)
from sales
group by cube(item name, color, clothes size);
The above query produces a relation whose schema is:
(item name, color, clothes size, sum(quantity))
So that the result of this query is indeed a relation, tuples in the result contain null as the value of those attributes not present in a particular grouping.
For example, tuples produced by grouping on clothes size have a schema (clothes
size, sum(quantity)). They are converted to tuples on (item name, color, clothes size,
sum(quantity)) by inserting null for item name and color.
Data cube relations are often very large. The cube query above, with 3 possible
colors, 4 possible item names, and 3 sizes, has 80 tuples. The relation of Figure 5.21
is generated using grouping by item name and color. It also uses all in place of null
so as to be more readable to the average user. To generate that relation in SQL, we
arrange to substitute all for null. The query:
select item name, color, sum(quantity)
from sales
group by cube(item name, color);
208 Chapter 5 Advanced SQL
THE DECODE FUNCTION
The decode function allows substitution of values in an attribute of a tuple. The
general form of decode is:
decode (value, match-1, replacement-1, match-2, replacement-2, ...,
match-N, replacement-N, default-replacement);
It compares value against the match values and if a match is found, it replaces the
attribute value with the corresponding replacement value. If no match succeeds,
then the attribute value is replaced with the default replacement value.
The decode function does not work as we might like for null values because,
as we saw in Section 3.6, predicates on nulls evaluate to unknown, which
ultimately becomes false. To deal with this, we apply the grouping function,
which returns 1 if its argument is a null value generated by a cube or rollup and
0 otherwise. Then the relation in Figure 5.21, with occurrences of all replaced
by null, can be computed by the query:
select decode(grouping(item name), 1, ’all’, item name) as item name
decode(grouping(color), 1, ’all’, color) as color
sum(quantity) as quantity
from sales
group by cube(item name, color);
generates the relation of Figure 5.21 with nulls. The substitution of all is achieved
using the SQL decode and grouping functions. The decode function is conceptually simple but its syntax is somewhat hard to read. See blue box for details.
The rollup construct is the same as the cube construct except that rollup
generates fewer group by queries. We saw that group by cube (item name, color,
clothes size) generated all 8 ways of forming a group by query using some (or all
or none) of the attributes. In:
select item name, color, clothes size, sum(quantity)
from sales
group by rollup(item name, color, clothes size);
group by rollup(item name, color, clothes size) generates only 4 groupings:
{ (item name, color, clothes size), (item name, color), (item name), () }
Notice that the order of the attributes in the rollup makes a difference; the final
attribute (clothes size, in our example) appears in only one grouping, the penultimate (second last) attribute in 2 groupings, and so on, with the first attribute
appearing in all groups but one (the empty grouping).
5.7 Summary 209
Why might we want the specific groupings that are used in rollup? These
groups are of frequent practical interest for hierarchies (as in Figure 5.19, for
example). For the location hierarchy (Region, Country, State, City), we may want
to group by Region to get sales by region. Then we may want to “drill down” to the
level of countries within each region, which means we would group by Region,
Country. Drilling down further, we may wish to group by Region, Country, State
and then by Region, Country, State, City. The rollup construct allows us to specify
this sequence of drilling down for further detail.
Multiple rollups and cubes can be used in a single group by clause. For
instance, the following query:
select item name, color, clothes size, sum(quantity)
from sales
group by rollup(item name), rollup(color, clothes size);
generates the groupings:
{ (item name, color, clothes size), (item name, color), (item name),
(color, clothes size), (color), () }
To understand why, observe that rollup(item name) generates two groupings,
{(item name), ()}, and rollup(color, clothes size) generates three groupings, {(color,
clothes size), (color), () }. The Cartesian product of the two gives us the six groupings
shown.
Neither the rollup nor the cube clause gives complete control on the groupings that are generated. For instance, we cannot use them to specify that we
want only groupings {(color, clothes size), (clothes size, item name)}. Such restricted
groupings can be generated by using the grouping construct in the having clause;
we leave the details as an exercise for you.
5.7 Summary
• SQL queries can be invoked from host languages, via embedded and dynamic
SQL. The ODBC and JDBC standards define application program interfaces
to access SQL databases from C and Java language programs. Increasingly,
programmers use these APIs to access databases.
• Functions and procedures can be defined using SQLprocedural extensions
that allow iteration and conditional (if-then-else) statements.
• Triggers define actions to be executed automatically when certain events
occur and corresponding conditions are satisfied. Triggers have many uses,
such as implementing business rules, audit logging, and even carrying out
actions outside the database system. Although triggers were not added to the
210 Chapter 5 Advanced SQL
SQL standard until SQL:1999, most database systems have long implemented
triggers.
• Some queries, such as transitive closure, can be expressed either by using
iteration or by using recursive SQL queries. Recursion can be expressed using
either recursive views or recursive with clause definitions.
• SQL supports several advanced aggregation features, including ranking and
windowing queries that simplify the expression of some aggregates and allow
more efficient evaluation.
• Online analytical processing (OLAP) tools help analysts view data summarized in different ways, so that they can gain insight into the functioning of
an organization.
◦ OLAP tools work on multidimensional data, characterized by dimension
attributes and measure attributes.
◦ The data cube consists of multidimensional data summarized in different
ways. Precomputing the data cube helps speed up queries on summaries
of data.
◦ Cross-tab displays permit users to view two dimensions of multidimensional data at a time, along with summaries of the data.
◦ Drill down, rollup, slicing, and dicing are among the operations that users
perform with OLAP tools.
• SQL, starting with the SQL:1999 standard, provides a variety of operators for
data analysis, including cube and rollup operations. Some systems support
a pivot clause, which allows easy creation of cross-tabs.
Review Terms
• JDBC
• ODBC
• Prepared statements
• Accessing metadata
• SQL injection
• Embedded SQL
• Cursors
• Updatable cursors
• Dynamic SQL
• SQL functions
• Stored procedures
• Procedural constructs
• External language routines
• Trigger
• Before and after triggers
• Transition variables and tables
• Recursive queries
• Monotonic queries
• Ranking functions
◦ Rank
◦ Dense rank
◦ Partition by
• Windowing
Practice Exercises 211
• Online analytical processing
(OLAP)
• Multidimensional data
◦ Measure attributes
◦ Dimension attributes
◦ Pivoting
◦ Data cube
◦ Slicing and dicing
◦ Rollup and drill down
• Cross-tabulation
Practice Exercises
5.1 Describe the circumstances in which you would choose to use embedded
SQL rather than SQL alone or only a general-purpose programming language.
5.2 Write a Java function using JDBC metadata features that takes a ResultSet
as an input parameter, and prints out the result in tabular form, with
appropriate names as column headings.
5.3 Write a Java function using JDBC metadata features that prints a list of all
relations in the database, displaying for each relation the names and types
of its attributes.
5.4 Show how to enforce the constraint “an instructor cannot teach in two
different classrooms in a semester in the same time slot.” using a trigger
(remember that the constraint can be violated by changes to the teaches
relation as well as to the section relation).
5.5 Write triggers to enforce the referential integrity constraint from section to
time slot, on updates to section, and time slot. Note that the ones we wrote
in Figure 5.8 do not cover the update operation.
5.6 To maintain the tot cred attribute of the student relation, carry out the following:
a. Modify the trigger on updates of takes, to handle all updates that can
affect the value of tot cred.
b. Write a trigger to handle inserts to the takes relation.
c. Under what assumptions is it reasonable not to create triggers on the
course relation?
5.7 Consider the bank database of Figure 5.25. Let us define a view branch cust
as follows:
create view branch cust as
select branch name, customer name
from depositor, account
where depositor.account number = account.account number
212 Chapter 5 Advanced SQL
branch(branch name, branch city, assets)
customer (customer name, customer street, cust omer city)
loan (loan number, branch name, amount)
borrower (customer name, loan number)
account (account number, branch name, balance )
depositor (customer name, account number)
Figure 5.25 Banking database for Exercises 5.7, 5.8, and 5.28 .
Suppose that the view is materialized; that is, the view is computed and
stored. Write triggers to maintain the view, that is, to keep it up-to-date on
insertions to and deletions from depositor or account. Do not bother about
updates.
5.8 Consider the bank database of Figure 5.25. Write an SQL trigger to carry
out the following action: On delete of an account, for each owner of the
account, check if the owner has any remaining accounts, and if she does
not, delete her from the depositor relation.
5.9 Show how to express group by cube(a, b, c, d) using rollup; your answer
should have only one group by clause.
5.10 Given a relation S(student,subject, marks), write a query to find the top n
students by total marks, by using ranking.
5.11 Consider the sales relation from Section 5.6. Write an SQL query to compute
the cube operation on the relation, giving the relation in Figure 5.21. Do
not use the cube construct.
Exercises
5.12 Consider the following relations for a company database:
• emp (ename, dname, salary)
• mgr (ename, mname)
and the Java code in Figure 5.26, which uses the JDBC API. Assume that
the userid, password, machine name, etc. are all okay. Describe in concise
English what the Java program does. (That is, produce an English sentence like “It finds the manager of the toy department,” not a line-by-line
description of what each Java statement does.)
5.13 Suppose you were asked to define a class MetaDisplay in Java, containing
a method static void printTable(String r); the method takes a relation name
r as input, executes the query “select * from r”, and prints the result out
in nice tabular format, with the attribute names displayed in the header of
the table.
Exercises 213
import java.sql.*;
public class Mystery {
public static void main(String[] args) {
try {
Connection con=null;
Class.forName("oracle.jdbc.driver.OracleDriver");
con=DriverManager.getConnection(
"jdbc:oracle:thin:star/X@//edgar.cse.lehigh.edu:1521/XE");
Statement s=con.createStatement();
String q;
String empName = "dog";
boolean more;
ResultSet result;
do {
q = "select mname from mgr where ename = ’" + empName + "’";
result = s.executeQuery(q);
more = result.next();
if (more) {
empName = result.getString("mname");
System.out.println (empName);
}
} while (more);
s.close();
con.close();
} catch(Exception e){e.printStackTrace();} }}
Figure 5.26 Java code for Exercise 5.12.
a. What do you need to know about relation r to be able to print the
result in the specified tabular format.
b. What JDBC methods(s) can get you the required information?
c. Write the method printTable(String r) using the JDBC API.
5.14 Repeat Exercise 5.13 using ODBC, defining void printTable(char *r) as a
function instead of a method.
5.15 Consider an employee database with two relations
employee (employee name, street, city)
works (employee name, company name, salary)
where the primary keys are underlined. Write a query to find companies
whose employees earn a higher salary, on average, than the average salary
at “First Bank Corporation”.
214 Chapter 5 Advanced SQL
a. Using SQL functions as appropriate.
b. Without using SQL functions.
5.16 Rewrite the query in Section 5.2.1 that returns the name and budget of all
departments with more than 12 instructors, using the with clause instead
of using a function call.
5.17 Compare the use of embedded SQL with the use in SQL of functions defined
in a general-purpose programming language. Under what circumstances
would you use each of these features?
5.18 Modify the recursive query in Figure 5.15 to define a relation
prereq depth(course id, prereq id, depth)
where the attribute depth indicates how many levels of intermediate prerequisites are there between the course and the prerequisite. Direct prerequisites have a depth of 0.
5.19 Consider the relational schema
part(part id, name, cost)
subpart(part id, subpart id, count)
A tuple (p1, p2, 3) in the subpart relation denotes that the part with part-id
p2 is a direct subpart of the part with part-id p1, and p1 has 3 copies of p2.
Note that p2 may itself have further subparts. Write a recursive SQL query
that outputs the names of all subparts of the part with part-id “P-100”.
5.20 Consider again the relational schema from Exercise 5.19. Write a JDBC
function using non-recursive SQL to find the total cost of part “P-100”,
including the costs of all its subparts. Be sure to take into account the
fact that a part may have multiple occurrences of a subpart. You may use
recursion in Java if you wish.
5.21 Suppose there are two relations r and s, such that the foreign key B of r
references the primary key Aof s. Describe how the trigger mechanism can
be used to implement the on delete cascade option, when a tuple is deleted
from s.
5.22 The execution of a trigger can cause another action to be triggered. Most
database systems place a limit on how deep the nesting can be. Explain
why they might place such a limit.
5.23 Consider the relation,r, shown in Figure 5.27. Give the result of the following query:
Exercises 215
building room number time slot id course id sec id
Garfield 359 A BIO-101 1
Garfield 359 B BIO-101 2
Saucon 651 A CS-101 2
Saucon 550 C CS-319 1
Painter 705 D MU-199 1
Painter 403 D FIN-201 1
Figure 5.27 The relation r for Exercise 5.23.
select building, room number, time slot id, count(*)
from r
group by rollup (building, room number, time slot id)
5.24 For each of the SQL aggregate functions sum, count, min, and max, show
how to compute the aggregate value on a multiset S1 ∪ S2, given the aggregate values on multisets S1 and S2.
On the basis of the above, give expressions to compute aggregate values
with grouping on a subset S of the attributes of a relation r(A, B,C, D, E),
given aggregate values for grouping on attributes T ⊇ S, for the following
aggregate functions:
a. sum, count, min, and max
b. avg
c. Standard deviation
5.25 In Section 5.5.1, we used the student grades view of Exercise 4.5 to write
a query to find the rank of each student based on grade-point average.
Modify that query to show only the top 10 students (that is, those students
whose rank is 1 through 10).
5.26 Give an example of a pair of groupings that cannot be expressed by using
a single group by clause with cube and rollup.
5.27 Given relation s(a, b, c), show how to use the extended SQL features to
generate a histogram of c versus a, dividing a into 20 equal-sized partitions
(that is, where each partition contains 5 percent of the tuples in s, sorted by
a).
5.28 Consider the bank database of Figure 5.25 and the balance attribute of the
account relation. Write an SQL query to compute a histogram of balance
values, dividing the range 0 to the maximum account balance present, into
three equal ranges.
216 Chapter 5 Advanced SQL
Tools
Most database vendors provide OLAP tools as part of their database systems, or
as add-on applications. These include OLAP tools from Microsoft Corp., Oracle
Express, and Informix Metacube. Tools may be integrated with a larger “business
intelligence” product such as IBM Cognos. Many companies also provide analysis
tools for specific applications, such as customer relationship management (for
example, Oracle Siebel CRM).
Bibliographical Notes
See the bibliographic notes of Chapter 3 for references to SQL standards and books
on SQL.
An excellent source for more (and up-to-date) information on JDBC, and on
Java in general, is java.sun.com/docs/books/tutorial. References to books on Java (including JDBC) are also available at this URL. The ODBC API is described in Microsoft
[1997] and Sanders [1998]. Melton and Eisenberg [2000] provides a guide to SQLJ,
JDBC, and related technologies. More information on ODBC, ADO, and ADO.NET
can be found on msdn.microsoft.com/data.
In the context of functions and procedures in SQL, many database products
support features beyond those specified in the standards, and do not support
many of the features of the standard. More information on these features may be
found in the SQL user manuals of the respective products.
The original SQL proposals for assertions and triggers are discussed in Astrahan et al. [1976], Chamberlin et al. [1976], and Chamberlin et al. [1981]. Melton and
Simon [2001], Melton [2002], and Eisenberg and Melton [1999] provide textbook
coverage of SQL:1999, the version of the SQL standard that first included triggers.
Recursive query processing was first studied in detail in the context of a query
language called Datalog, which was based on mathematical logic and followed
the syntax of the logic programming language Prolog. Ramakrishnan and Ullman
[1995] provides a survey of results in this area, including techniques to optimize
queries that select a subset of tuples from a recursively defined view.
Gray et al. [1995] and Gray et al. [1997] describe the data-cube operator.
Efficient algorithms for computing data cubes are described by Agarwal et al.
[1996], Harinarayan et al. [1996], and Ross and Srivastava [1997]. Descriptions of
extended aggregation support in SQL:1999 can be found in the product manuals
of database systems such as Oracle and IBM DB2.
There has been a substantial amount of research on the efficient processing of
“top-k” queries that return only the top-k-ranked results. A survey of that work
appears in Ilyas et al. [2008].
CHAPTER 6
Formal Relational Query
Languages
In Chapters 2 through 5 we introduced the relational model and covered SQL in
great detail. In this chapter we present the formal model upon which SQL as well
as other relational query languages are based.
We cover three formal languages.We start by presenting the relational algebra,
which forms the basis of the widely used SQL query language. We then cover the
tuple relational calculus and the domain relational calculus, which are declarative
query languages based on mathematical logic.
6.1 The Relational Algebra
The relational algebra is a procedural query language. It consists of a set of operations that take one or two relations as input and produce a new relation as
their result. The fundamental operations in the relational algebra are select, project,
union, set difference, Cartesian product, and rename. In addition to the fundamental
operations, there are several other operations—namely, set intersection, natural
join, and assignment. We shall define these operations in terms of the fundamental
operations.
6.1.1 Fundamental Operations
The select, project, and rename operations are called unary operations, because
they operate on one relation. The other three operations operate on pairs of
relations and are, therefore, called binary operations.
6.1.1.1 The Select Operation
The select operation selects tuples that satisfy a given predicate. We use the
lowercase Greek letter sigma () to denote selection. The predicate appears as a
subscript to . The argument relation is in parentheses after the . Thus, to select
217
218 Chapter 6 Formal Relational Query Languages
ID name dept name salary
10101 Srinivasan Comp. Sci. 65000
12121 Wu Finance 90000
15151 Mozart Music 40000
22222 Einstein Physics 95000
32343 El Said History 60000
33456 Gold Physics 87000
45565 Katz Comp. Sci. 75000
58583 Califieri History 62000
76543 Singh Finance 80000
76766 Crick Biology 72000
83821 Brandt Comp. Sci. 92000
98345 Kim Elec. Eng. 80000
Figure 6.1 The instructor relation.
those tuples of the instructor relation where the instructor is in the “Physics”
department, we write:
dept name = “Physics” (instructor )
If the instructor relation is as shown in Figure 6.1, then the relation that results
from the preceding query is as shown in Figure 6.2.
We can find all instructors with salary greater than $90,000 by writing:
salary>90000 (instructor)
In general, we allow comparisons using =, =, <, ≤, >, and ≥ in the selection
predicate. Furthermore, we can combine several predicates into a larger predicate
by using the connectives and (∧), or (∨), and not (¬). Thus, to find the instructors
in Physics with a salary greater than $90,000, we write:
dept name = “Physics” ∧ salary>90000 (instructor )
The selection predicate may include comparisons between two attributes. To
illustrate, consider the relation department. To find all departments whose name
is the same as their building name, we can write:
dept name = building (department)
ID name dept name salary
22222 Einstein Physics 95000
33456 Gold Physics 87000
Figure 6.2 Result of dept name = “Physics” (instructor ).
6.1 The Relational Algebra 219
SQL VERSUS RELATIONAL ALGEBRA
The term select in relational algebra has a different meaning than the one used in
SQL, which is an unfortunate historical fact. In relational algebra, the term select
corresponds to what we refer to in SQL as where. We emphasize the different
interpretations here to minimize potential confusion.
6.1.1.2 The Project Operation
Suppose we want to list all instructors’ ID, name, and salary, but do not care
about the dept name. The project operation allows us to produce this relation.
The project operation is a unary operation that returns its argument relation,
with certain attributes left out. Since a relation is a set, any duplicate rows are
eliminated. Projection is denoted by the uppercase Greek letter pi (). We list
those attributes that we wish to appear in the result as a subscript to . The
argument relation follows in parentheses. We write the query to produce such a
list as:
ID, name, salary (instructor )
Figure 6.3 shows the relation that results from this query.
6.1.1.3 Composition of Relational Operations
The fact that the result of a relational operation is itself a relation is important.
Consider the more complicated query “Find the name of all instructors in the
Physics department.” We write:
ID name salary
10101 Srinivasan 65000
12121 Wu 90000
15151 Mozart 40000
22222 Einstein 95000
32343 El Said 60000
33456 Gold 87000
45565 Katz 75000
58583 Califieri 62000
76543 Singh 80000
76766 Crick 72000
83821 Brandt 92000
98345 Kim 80000
Figure 6.3 Result of ID, name, salary (instructor ).
220 Chapter 6 Formal Relational Query Languages
name (dept name = “Physics” (instructor))
Notice that, instead of giving the name of a relation as the argument of the
projection operation, we give an expression that evaluates to a relation.
In general, since the result of a relational-algebra operation is of the same type
(relation) as its inputs, relational-algebra operations can be composed together
into a relational-algebra expression. Composing relational-algebra operations
into relational-algebra expressions is just like composing arithmetic operations
(such as +, −, ∗, and ÷) into arithmetic expressions.We study the formal definition
of relational-algebra expressions in Section 6.1.2.
6.1.1.4 The Union Operation
Consider a query to find the set of all courses taught in the Fall 2009 semester, the
Spring 2010 semester, or both. The information is contained in the section relation
(Figure 6.4). To find the set of all courses taught in the Fall 2009 semester, we
write:
course id (semester = “Fall” ∧ year=2009 (section))
To find the set of all courses taught in the Spring 2010 semester, we write:
course id (semester = “Spring” ∧ year=2010 (section))
To answer the query, we need the union of these two sets; that is, we need all
section IDs that appear in either or both of the two relations. We find these data
